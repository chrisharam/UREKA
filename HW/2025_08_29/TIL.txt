-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
                                Variable
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
1. false로 인식하는 것들
    number = 0  &  string = "" or "null"  &  number/"string"
    true로는 number=100일 때도 true라고 판단.
    --> 값의 존재유무 = true/false

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
2. 변수 타입
    0)var = 범위 모호 // block 과 상관없이 사용됨 = block을 넘나들며 사용됨.
        function 안에서 선언 = 함수 스코프 = local 취급함.
        function 밖에서 선언 = 전역 변수


    1)let & const 
        (1) 공통점
            선언된 위치에 따라 스코프 결정됨.
            메모리 주소 참조 가능
        (2) 차이점
            <1> primitive type
                - let   : 변수 // 값 재할당 O
                - const : 상수 // 값 재할당 X // final과 유사 개념
            <2> Object/Array/function type
                - let   : 메모리 주소 가변성 // 참조형 변수 재할당 가능 // 수정 가능
                - const : 메모리 주소 불변성 // 참조형 변수 재할당 불가능 // 수정 가능

            (let 예시)
                let myObject = { name: '첫 번째' };
                console.log(myObject); // { name: '첫 번째' }

                // 새로운 객체를 재할당
                myObject = { name: '두 번째' };
                console.log(myObject); // { name: '두 번째' }
            (const 예시)
                const myObject = { name: '첫 번째' };
                console.log(myObject); // { name: '첫 번째' }

                // 객체 내부의 속성을 수정
                myObject.name = '두 번째';
                console.log(myObject); // { name: '두 번째' }

                // 아래 코드는 에러를 발생시킵니다.
                myObject = { name: '세 번째' }; 
                ❌ TypeError: Assignment to constant variable.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

3. Scope
    1) global scope
        var(window 객체) <-- 사용하면 error 다수 발생
        let, const(window 객체가 아님) <-- ok
    2) function scope
        : 함수 내부라면, 함수 내부에 있는 {}을 무시하는 변수
    3) block scope
        : {} 안에서만 적용되는 local 변수

-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
                                Object
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------

1. function 객체 VS Object 객체
    --> 반환값으로 
        - 단순히 '값/연산/기존 객체' 만을 원할 때 = 함수 호출
        - '새로운 객체를 생성'하고 싶을 때 = new 키워드 사용
    
    EX)
        let x = Boolean(true)   <-- function 객체
        let y = new Boolean(false) <-- object 객체

    (1)공통점 
        둘 다 사실상 Function 객체
        둘 다 new 키워드를 붙이면 인스턴스를 만들 수 있음
        프로토타입 기반으로 동작함

    (2)차이점
    function 객체:
        일반 함수처럼 호출 가능 + 생성자로도 사용 가능
        prototype 메서드는 수동 추가
    class 객체:
        함수와 본질적으로 같지만, '생성자 전용 문법' = 새로운 객체를 파생
        new 없이 호출 불가
        prototype 메서드 자동 정의
        strict mode 강제

    EX_function)
        function Person(name) {
            return { name: name }; // 객체를 생성해서 반환
        }

        let p1 = Person("Alice"); // 함수가 반환하는 객체 리터럴을 받음

        console.log(p1); // { name: 'Alice' }
        console.log(typeof p1); // object

    EX_Object)
        function Person(name) {
        this.name = name;   // this는 자동으로 생성된 새로운 객체를 가리킴
        }

        let p2 = new Person("Bob"); // new 키워드를 사용해 새로운 객체를 생성

        console.log(p2); // Person { name: 'Bob' }
        console.log(p2); // object


    (3) this의 기능 = 맥락에 따라 다름:
        (1) 객체의 메서드가 아닌, 함수가 단독으로 직접 호출될 때 = 전역 객체
        (2) 객체의 메서드로 호출될 때  = 해당 객체를 가르킴(속성값)
        (3) new 키워드를 사용하며 호출될 때 = 새로 생긴 객체를 가르킴

    EX_1)
        function logThis() {
            console.log(this); // 전역 객체(예: window)를 가리킴
            }
        logThis();
    EX_2)
        const myObject = {
            name: "Alice",
            sayName: function() {
                         console.log(this.name); // 'this'는 myObject를 가리킴
                        }
                    };
        myObject.sayName(); // "Alice" 출력
    EX_3)
        function Person(name) {
            this.name = name; // 'this'는 새로 생성된 객체를 가리킴
            }
        const person1 = new Person("Bob");
        console.log(person1.name); // "Bob" 출력
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

2. wrapper object
    --> primitive value를 객체처럼 다룰 수 있도록, JS engine이 임의로 래퍼 객체를 생성
    --> primitive value에 객체 기능 부여
    --> 종류: String, number, Boolean

    EX)
    // primitive value인 상태 != object
        const name = 'Hello World'; // 원시 값 (string)

    //호출 시, wrapper object로 감쌈
        console.log(name.length); // 11
        console.log(name.toUpperCase()); // "HELLO WORLD"

    // 속성 접근이 끝나면, 임의로 생성된 래퍼 객체는 파괴됨


- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

3. 객체 선언 & 생성

    (1) var p1 = {name: "p1"}; <-- 객체 리터럴 이용

    (2) var p2 = new Object(); p2.name="abc" <-- 생성자

    (3) function Person(name){   <-- 사용자 지정 생성자 이용
            this.name = name;
        }
        var p3 = new Person("abc");
        var p4 = new Person("def");


    (예시)
        (1)
            var p1 = {
            name: "p1"
            };
            p1.age = 20;

            console.log(p1.name);
            console.log(p1.age);

        (2)
            var p2 = new Object();

            p2.name = "abc";
            p2.age = 20;

            console.log(p2.name);
            console.log(p2.age);

        (3)
            function Person(name) {
                    this.name = name;
                }

            var p3 = new Person("abc");
            var p4 = new Person("def");

            // p3 객체에 age 속성 추가
            p3.age = 30;

            // p4 객체에 age 속성 추가
            p4['age'] = 25;

            console.log(p3); // { name: 'abc', age: 30 }
            console.log(p4); // { name: 'def', age: 25 }
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

4. Primitive type  VS  Reference type 비교

<script>
    1. primitive type
        let name = "정하람";
        let age = 26;
        let height = 180;
        let isPerson = true;
        let price;
        let property = null;
        console.log(name,age,height,isPerson,price,property);


    2. reference type
        let person={
            name : "정하람",
            age : 26,
            height : 180,
            isPerson : true,
            price,
            property : null
        }
        console.log(person);


    3. const reference type
        const a_person={
            name : "정하람",
            age : 26,
            height : 180,
            isPerson : true,
            price,
            property : null
        }
        a_person.name="홍길동";
        console.log(a_person);

        a_person = new Person{}; //ERROR

    </script>
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------