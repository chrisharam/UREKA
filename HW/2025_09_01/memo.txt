function의 사용이유 : '재사용성'

function 선언
(1) this 모호성 존재
    let myFunction = function(a, b) {return a * b};
(2) this 모호성 해결
    myFunction = (a, b) => a * b;

- 플러스 연산자 사용
    <script>
        function greet(name, age){
            return "hello "+ name+"! You are "+age+" years old.";
        }
        let value = greet("haram",26);
        console.log(value);
    </script>

- 백틱 사용
    <script>
        function greet(name, age){
            return `hello  ${name}! You are ${age} years old.`;
        } 
        let value = greet("haram",26);
        console.log(value);
        value = greet("hani",14);
        console.log(value);
    </script>

함수 선언 시 structure
heap(function 작동) --> stack(argument로 지정되는 데이터를 register가 저장)
greet 함수가 호출 --> parameter는 register가 기억 --> 함수 수행시 parameter호출
--> return된 데이터를 변수로 받음(window가 기억)

--> heap과 stack

*** 함수 안에 함수를 인자로 넣기 ***

-----------------------------------------------------------------------------------
javaScript의 Event
1. event 지정 0 & 호출 X
<button onclick="document.getElementById('demo').innerHTML=Date()">The time is?</button>
           Event    handler
        eventListener

--------------------------------
2. 콜백함수 = 함수의 인자값으로 전달되는 함수(인자로서의 함수)
--> 바로 호출하지 않는 것이 핵심
--> 인자로 작성할 때, ()를 빼고 작성해야 함.

=========================================================================
배열
1. 선언
    (1)const points = new Array(); <-- 동적 할당, or 자리수를 제한시킴(숫자)
    (2)const points = [];
    ex)
    const points = new Array(40, 100, 1, 5, 25, 10);
    const points = [40, 100, 1, 5, 25, 10];

    (3) Dictionary 처럼 선언
    const myObj = {
        name: "John",
        age: 30,
        cars: [
            {name:"Ford", models:["Fiesta", "Focus", "Mustang"]},
            {name:"BMW", models:["320", "X3", "X5"]},
            {name:"Fiat", models:["500", "Panda"]}
        ]
    }

==============================================================================
객체 - 종속적인 함수-그에 종속되는 함수.. 를 기준으로 아래와 같이 코딩하기

    let obj = {
        myVar: 'foo',

        myMeth: function jes() { 
            console.log(this.myVar) ; //수행 컨텍스트가 obj

            setTimeout(() => { //화살표 함수, function()객체가 만들어질때 this를 바인딩, bind()한 것처럼 lexical scope을 갖는다
            console.log(this.myVar); //수행 컨텍스트가 obj
            }, 1000);
        }
    }
obj.myMeth(); // foo  foo